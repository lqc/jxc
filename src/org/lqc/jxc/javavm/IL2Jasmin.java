package org.lqc.jxc.javavm;

import java.io.PrintStream;

import org.lqc.jxc.CompilerException;
import org.lqc.jxc.il.Assignment;
import org.lqc.jxc.il.Branch;
import org.lqc.jxc.il.Builtin;
import org.lqc.jxc.il.Call;
import org.lqc.jxc.il.Callable;
import org.lqc.jxc.il.CompoundOperation;
import org.lqc.jxc.il.Constant;
import org.lqc.jxc.il.Expression;
import org.lqc.jxc.il.Function;
import org.lqc.jxc.il.Label;
import org.lqc.jxc.il.Loop;
import org.lqc.jxc.il.Module;
import org.lqc.jxc.il.Nop;
import org.lqc.jxc.il.Operation;
import org.lqc.jxc.il.Return;
import org.lqc.jxc.il.ReturnVoid;
import org.lqc.jxc.il.VariableValue;
import org.lqc.jxc.types.Type;

public class IL2Jasmin {
	
	private PrintStream out;
	
	public IL2Jasmin(PrintStream out) {
		/* do some init */	
		this.out = out;
	}	 
	
	public void emmit(Module m) {
		out.print("; Class generated by jxCompiler\n\n");
				
		/* preface block */
		out.printf(".class public %s\n", m.getModuleName());
		out.printf(".super java/lang/Object\n\n");	
				
		/* main stub */
		out.print("; Main stub\n");
		out.print(".method public static main([Ljava/lang/String;)V\n");
		out.print(".limit locals 1\n");
		out.print(".limit stack 1\n");
		out.printf("invokestatic %s/main()I\n", m.getModuleName());
		out.print("pop\n");
		out.print("return\n");
		out.print(".end method\n\n");
				
		out.printf("; Module content\n\n");		
		
		for(Callable f : m.allFunctions()) {
			this.emmit(f);
		}				
	}
	
	public void emmit(Callable c) {
		if(c instanceof Function) {
			emmit( (Function)c);			
		}
		else if (c instanceof Builtin) {
			/* don't print */
		}
		else 
			throw new CompilerException("Unknown type of callable - internal error !?");
	}
	
	public void emmit(Function f) {
		out.printf(".method public static %s\n", 
				JType.methodSignature(f.callSignature()) );
		out.printf(".limit locals %d\n", f.allVariables().size());
		out.printf(".limit stack %d\n", calculateMaxStack(f) );
		for(Operation op : f) 
			this.emmit(op);
		out.printf(".end method\n\n");		
	}
	
	public void emmit(Operation op) {
		
		/* Expressions */	
		if(op instanceof Constant) {
			Constant c = (Constant)op;
			
			JType jt = JType.fromILType(c.getType());
			out.printf("%s\n", jt.loadConstant(c.value()) );
			return;
		}
		
		if(op instanceof VariableValue) {
			VariableValue v = (VariableValue)op;
			JType jt = JType.fromILType(v.getType());
			
			out.printf("%s_%d\n", jt.loadVar(), 
					v.reference().localID());
			return;
		}
		
		if(op instanceof Assignment) {
			Assignment a = (Assignment)op;
			
			this.emmit(a.getArgument());
			JType jt = JType.fromILType(a.getType());
			out.printf("%s_%d\n", jt.storeVar(), 
					a.getTarget().localID());
			return;			
		}
		
		if(op instanceof Call) {
			Call c = (Call)op;
						
			for(Expression e : c.args()) {
				this.emmit(e);
			}
						
			if(c.target() instanceof Builtin) {					
				out.println(((Builtin)c.target()).getContents());
			}
			else {
				out.printf("invokestatic %s/%s\n",
						c.target().container().absolutePath(),
						JType.methodSignature(c.target().callSignature()) );
			}	
			return;
		}
						
		out.printf(".line %d\n", op.line);
				
		if(op instanceof ReturnVoid) {
			out.print("return\n");
			return;						
		}
		
		if(op instanceof Return) {
			Return r = (Return)op;
			/* calculate expression */
			Expression e = r.returnValue;
			this.emmit(r.returnValue);
			
			/* return */
			JType jt = JType.fromILType(e.getType());
			out.println(jt.returnOp());
			return;						
		}	
		
		if(op instanceof Nop) {
			out.println("nop");
			return;
		}
		
		if(op instanceof Branch) {
			Branch branch = (Branch)op;				
			
			Expression cond = branch.getCondition();			
			if( branch.getOperationB().isNop() ) 
			{					
				Label trueLabel = branch.slink().getUniqueLabel();
				Label falseLabel = branch.slink().getUniqueLabel();
				
				this.emmitCondition(cond, trueLabel, falseLabel);
				out.printf(trueLabel.emmit());
				this.emmit(branch.getOperationA());
				out.printf(falseLabel.emmit());				
			}
			else {
				Label trueLabel = branch.slink().getUniqueLabel();
				Label falseLabel = branch.slink().getUniqueLabel();
				Label endLabel = branch.slink().getUniqueLabel();
				
				this.emmitCondition(cond, trueLabel, falseLabel);
				trueLabel.emmit();				
				this.emmit(branch.getOperationA());
				out.printf("goto %s\n", endLabel.getName());
				out.printf(falseLabel.emmit());
				this.emmit(branch.getOperationB());
				out.printf(endLabel.emmit());				
			}
			return;			
		}
		
		if(op instanceof Loop) {
			Loop loop = (Loop)op;
			Label trueLabel = loop.slink().getUniqueLabel();
			Label falseLabel = loop.slink().getUniqueLabel();
			Label checkLabel = loop.slink().getUniqueLabel();
			
			/* mark as used */
			checkLabel.getName();
			
			/* emmit */			
			out.printf(checkLabel.emmit());
			this.emmitCondition(loop.getCondition(), 
					trueLabel, falseLabel);
			out.printf(trueLabel.emmit());			
			this.emmit(loop.getBodyBlock());			
			out.printf("goto %s\n", checkLabel.getName());
			out.printf(falseLabel.emmit());			
			return;
		}
				
		if(op instanceof CompoundOperation) {
			for(Operation opx : (CompoundOperation)op) this.emmit(opx);
			return;
		}
		
		throw new CompilerException("Unknown operation to emmit: " + op);
	}
	
	private void emmitCondition(Expression cond, Label t, Label f) {
		/* we know cond is of type boolean */
		if(cond instanceof Constant) {
			Boolean b = ((Constant<Boolean>)cond).value();
			if(!b) {
				out.printf("goto %s\n", f.getName());								
			}			
			return;
		}
		
		if(cond instanceof VariableValue) {
			this.emmit(cond);
			out.printf("ifne %s\n", f.getName());
			return;
		}
		
		if(cond instanceof Call) {
			Call c = (Call)cond;
			
			if(! (c.target() instanceof Builtin))
			{
				this.emmit(cond);
				out.printf("ifne %s\n", f.getName());
			}
			else {
				/* builtin */
				for(Expression e : c.args()) {
					this.emmit(e);
				}
				
				out.printf(((Builtin)c.target()).getBranchTemplate()
						+ "\n", f.getName() );								
			}			
			return;
		}		
		
		throw new CompilerException("Not implemented yet: " + cond);
	}
	
	private static int calculateMaxStack(Function f) 
	{
		int maxStack;
		
		/* default is size of return type 
		 * assert(JType(void).opsize == 0) */		
		Type rt = f.callSignature().type.getReturnType();
		maxStack = JType.sizeof(rt);
		
		/* every instruction is finite and complete 
		 * i.e. stack height before and after processing 
		 * an operation is the same */ 
		 
		 /* maxStack(f) = max({maxStack(op) : op \in f}) */
		for(Operation op : f) {
			maxStack = Math.max(maxStack, 
					calculateMaxStack(op) );
		}		
		
		return maxStack;		
	}
	
	private static int calculateMaxStack(Operation op) {
		/* Simple ops */
		if(op instanceof Return) {
			return calculateMaxStack(((Return)op).returnValue);
		}		 
		
		if(op instanceof ReturnVoid) {
			return 0;
		}
		
		if(op instanceof Nop) {
			return 0;
		}
		
		/* Expressions */
		if(op instanceof Constant) {
			return JType.sizeof( ((Constant)op).getType() );
		}		
		
		if(op instanceof VariableValue) {
			return JType.sizeof( ((VariableValue)op).getType() );			
		}
		
		if(op instanceof Call) {
			Call c = (Call)op;
			
			/* return type size */
			int m = JType.sizeof( c.getType() );
			
			int k = 0;
			int s = 0;
			int n = 0;
			
			/* XXX: test this roughly */
			for(Expression e : c.args()) 
			{	
				n = calculateMaxStack(e);				
				k = JType.sizeof( e.getType() );
								
				/* 
				 * n = space needed to calculate this argument  
				 * k = space to hold values of arguments
				 */ 
				m = Math.max(m, s+n);
				s += k;
			}	
			
			return m;
		}	
		
		if(op instanceof Assignment) {
			Assignment assign = (Assignment)op;
			int n = calculateMaxStack(assign.getArgument());
			
			/* we also might need an address */
			return n + 1;			
		}
		
		/* complex operations */
		if(op instanceof Branch) {
			Branch branch = (Branch)op;
			
			int cn = calculateMaxStack(branch.getCondition());
			int an = calculateMaxStack(branch.getOperationA());
			int bn = calculateMaxStack(branch.getOperationB());
			
			return Math.max(cn, Math.max(an, bn));
		}
		
		if(op instanceof Loop) {
			Loop loop = (Loop)op;
			
			return Math.max(
					calculateMaxStack(loop.getCondition()),
					calculateMaxStack(loop.getBodyBlock()) );					
		}
		
		/* compund operation */
		if(op instanceof CompoundOperation) {
			int n = 0;
			
			for(Operation ox : (CompoundOperation)op) 
				n = Math.max(n, calculateMaxStack(ox));
			
			return n;			
		}
		
		/* in case we missed something */
		throw new CompilerException(
			"Unmatched Operation in calcMaxStack");		
	}
}
