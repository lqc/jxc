package org.lqc.jxc;

import java_cup.runtime.*;

import org.lqc.jxc.types.*;
import org.lqc.jxc.tokens.*;

import java.util.List;
import java.util.Vector;

parser code {:
	
	public void syntax_error(Symbol token)
	{
		StringBuffer bf = new StringBuffer("[ERROR]");
			
		bf.append(" Line ");
		bf.append(token.left+1);
		bf.append(", column ");
		bf.append(token.right+1);
		bf.append(": " + token.toString());
					
		System.out.println(bf);
	}
:};

/* Some terminal signs */
terminal SEMI,COLON;
terminal LPAR, RPAR;
terminal LCURLY, RCURLY;
terminal EQUAL, EQEQ, NEQEQ;
terminal LT, LTEQ, GT, GTEQ;
terminal PLUS, MINUS, TIMES, DIVIDE, MODULO;
terminal NEG, UPLUS, UMINUS, PLUSPLUS, MINUSMINUS;

terminal LOGOR, LOGAND;

terminal Integer INT;
terminal Double REAL;
terminal Boolean BOOLEAN;
terminal String STRING;
terminal String ID;

terminal IF;
terminal ELSE;
terminal FOR;
terminal WHILE;
terminal RETURN;
terminal DEFINES;
terminal IMPLEMENTS; 

terminal Type TYPE;

non terminal ConstantExpr constant;

/* Function lists */
non terminal CompileUnit prog;
/* non terminal List<FunctionSign> func_sig_list; */
non terminal List<FunctionDecl> func_list; 
/* non terminal FunctionSign func_sig; */
non terminal FunctionDecl func_decl;

/* Argument lists */
non terminal List<ArgumentDecl> arg_dlist;
non terminal List<ArgumentDecl> arg_dlist_ne;
non terminal ArgumentDecl arg_decl;

non terminal List<Instruction> instr_list;
non terminal Instruction instr;
non terminal ComplexInstr complex_instr;


non terminal List<Declaration> var_decl;
non terminal List<Pair<String,Expression>> declarator_list;
non terminal Pair<String,Expression> declarator;

non terminal Expression expr;
non terminal Expression bool_expr_or, bool_expr_and, bool_expr_cmp, bool_expr_rel; 
non terminal Expression num_expr_add, num_expr_mul, unary_expr, simple_expr;
non terminal Expression assign_expr;

non terminal TypeCast type_cast;

non terminal List<Expression> expr_list;

non terminal CondInstr cond_instr;
non terminal LoopInstr loop_instr;
non terminal ReturnInstr return_instr;

precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MODULO;
precedence left UMINUS, UPLUS, NEG;
precedence left ELSE;

prog ::= func_list:fl 	
	{: RESULT = new CompileUnit(flleft, flright, "Unit", fl); :} 	
;

func_list ::= func_list:fl func_decl:fd {: 
				RESULT = fl;
				RESULT.add(fd); :} |
			  func_decl:fd {:
			    RESULT = new Vector<FunctionDecl>();
			    RESULT.add(fd); :}
;

arg_dlist ::= arg_dlist_ne:al {: RESULT = al; :} | 
						      {: RESULT = new Vector<ArgumentDecl>(); :}; 
						      
arg_dlist_ne ::= arg_dlist_ne:al COLON arg_decl:arg	{: al.add(arg); RESULT = al; :} | 
				 arg_decl:arg {: RESULT = new Vector<ArgumentDecl>(); 
				                 RESULT.add(arg); 
				              :};


arg_decl ::= TYPE:type ID:id {: RESULT = new ArgumentDecl(typeleft, typeright, type, id); :};

/* Function Implementation */
func_decl ::= TYPE:rt ID:fid LPAR arg_dlist:args RPAR complex_instr:ci {:							
				RESULT = new FunctionDecl(rtleft, rtright, fid, rt, args, ci);
:};

/*** INSTRUCTIONS ***/

instr_list ::= instr:i {:
					RESULT = new Vector<Instruction>();
					RESULT.add(i); :} |
			   var_decl:vd {:
			   		RESULT = new Vector<Instruction>();
			   		RESULT.addAll(vd); :} |
			   instr_list:ilist instr:i {:
			   		ilist.add(i);
			   		RESULT = ilist; :} |
			   instr_list:ilist var_decl:vd {:
			   		RESULT = ilist;
			   		ilist.addAll(vd); :}
;

instr ::= complex_instr:ci {: RESULT = ci; :} |		  
		  expr:e SEMI {: RESULT = e; :} |		  
		  cond_instr:i {: RESULT = i; :} | 
		  loop_instr:i {: RESULT = i; :} |
		  return_instr:i {: RESULT = i; :} |
		  SEMI {: RESULT =  new EmptyInstruction(); :}  
;


assign_expr ::= ID:id EQUAL:op expr:e {: 
					RESULT = new AssignmentInstr(opleft, opright, id, e); :} |
				 ID:id PLUSPLUS:op {:
				 	RESULT = new IncrementInstr(opleft, opright, id, 1); :} |
				 ID:id MINUSMINUS:op {:
				 	RESULT = new IncrementInstr(opleft, opright, id, -1); :}
;

cond_instr ::= IF:op LPAR expr:e RPAR instr:i {:
				  RESULT = new CondInstr(opleft, opright, e, i, Instruction.EMPTY); :} |
			   IF:op LPAR expr:e RPAR instr:i1 ELSE instr:i2 {:
			      RESULT = new CondInstr(opleft, opright, e, i1, i2); :} 
;

loop_instr ::= WHILE:op LPAR expr:e RPAR instr:i {:
				  RESULT = new LoopInstr(opleft, opright, e, i, Instruction.EMPTY, Instruction.EMPTY); :} |
			  FOR:op LPAR assign_expr:init SEMI expr:e SEMI assign_expr:post RPAR instr:body
			  {:
			  	RESULT = new LoopInstr(opleft, opright, e, body, init, post); :}
;

return_instr ::= RETURN:ret SEMI {: RESULT = new ReturnInstr(retleft, retright, Expression.VOID); :} |
				 RETURN:ret expr:e SEMI {: RESULT = new ReturnInstr(retleft, retright,e); :}
;

/** Complex instruction **/
complex_instr ::= LCURLY:s instr_list:ilist RCURLY {:
					RESULT = new ComplexInstr(sleft, sright, ilist); :}
;

/** Variable declaration instruction **/
var_decl ::= TYPE:t declarator_list:dlist SEMI {:
			List<Declaration> nl = new Vector<Declaration>(dlist.size()); 					
			for(Pair<String, Expression> decl : dlist) {
				nl.add( new VarDecl(tleft, tright, t, decl.first(), decl.second()));
			};
			RESULT = nl; 
			:}
;

declarator_list ::= declarator:d {: 
					    RESULT = new Vector<Pair<String,Expression>>();
					    RESULT.add(d); :} |
					declarator_list:dlist COLON declarator:d {:
					    dlist.add(d);
					    RESULT = dlist; :}
;

declarator ::= ID:id {: 
					RESULT = new Pair<String,Expression>(id, Expression.NULL); 
					 :} |
			   ID:id EQUAL expr:e {: 
			        RESULT = new Pair<String,Expression>(id, e);
			        :}
;

/*** EXPRESSIONS ***/
expr ::= bool_expr_or:e {: RESULT =e; :} |
		 assign_expr:e {: RESULT = e; :}		 
;

/** Boolean Expressions **/
bool_expr_or ::= bool_expr_and:e {: RESULT = e; :} |
                 bool_expr_or:e1 LOGOR:op bool_expr_and:e2 {:
                      RESULT = new FunctionCall(opleft, opright, "_LOR",  e1, e2); :}
; 
                      
bool_expr_and ::= bool_expr_cmp:e {: RESULT = e; :} |
                  bool_expr_and:e1 LOGAND:op bool_expr_cmp:e2 {:
                      RESULT = new FunctionCall(opleft, opright, "_LAND",  e1, e2); :}
; 

bool_expr_cmp ::= bool_expr_rel:e {: RESULT = e; :} |
                  bool_expr_cmp:e1 EQEQ:op bool_expr_rel:e2 {:
                      RESULT = new FunctionCall(opleft, opright, "_EQEQ", e1, e2); :} |
                  bool_expr_cmp:e1 NEQEQ:op bool_expr_rel:e2 {:
                      RESULT = new FunctionCall(opleft, opright, "_NEQEQ", e1, e2); :}                      
; 

bool_expr_rel ::= num_expr_add:e {: RESULT = e; :} |
                  num_expr_add:e1 LT:op num_expr_add:e2 {:
                      RESULT = new FunctionCall(opleft, opright, "_LT", e1, e2); :} |
                  num_expr_add:e1 GT:op num_expr_add:e2 {:
                      RESULT = new FunctionCall(opleft, opright, "_GT", e1, e2); :} |
                  num_expr_add:e1 LTEQ:op num_expr_add:e2 {:
                      RESULT = new FunctionCall(opleft, opright, "_LE", e1, e2); :} |
                  num_expr_add:e1 GTEQ:op num_expr_add:e2 {:
                      RESULT = new FunctionCall(opleft, opright, "_GE", e1, e2); :}
;

num_expr_add ::= num_expr_mul:e {: RESULT = e; :} |
                  num_expr_add:e1 PLUS:op num_expr_mul:e2 {:
                      RESULT = new FunctionCall(opleft, opright,"_ADD", e1, e2); :} |
                  num_expr_add:e1 MINUS:op num_expr_mul:e2 {:
                      RESULT = new FunctionCall(opleft, opright,"_SUB", e1, e2); :}
;

num_expr_mul ::= unary_expr:e {: RESULT = e; :} |
                  num_expr_mul:e1 TIMES:op unary_expr:e2 {:
                      RESULT = new FunctionCall(opleft, opright,"_MUL", e1, e2); :} |
                  num_expr_mul:e1 DIVIDE:op unary_expr:e2 {:
                      RESULT = new FunctionCall(opleft, opright,"_DIV", e1, e2); :} |
                  num_expr_mul:e1 MODULO:op unary_expr:e2 {:
                      RESULT = new FunctionCall(opleft, opright,"_REM", e1, e2); :}
;

unary_expr ::= simple_expr:e {: RESULT = e; :} |			   
               NEG:op unary_expr:e {: 
                   RESULT = new FunctionCall(opleft, opright, "_LNEG", e); :} |  
               PLUS:op unary_expr:e {: 
                   RESULT = e; :} %prec UPLUS |
               MINUS:op unary_expr:e {: 
                   RESULT = new FunctionCall(opleft, opright, "_NNEG", e); :} %prec UMINUS
;

simple_expr ::= ID:id {: RESULT = new VarExpr(idleft, idright, id); :} |
				ID:id LPAR expr_list:elist RPAR {:
                	RESULT = new FunctionCall(idleft, idright, id, elist); :} | 
                ID:id LPAR RPAR {:
                     RESULT = new FunctionCall(idleft, idright, id); :} |
                LPAR expr:e RPAR {: RESULT = e; :} |                
                constant:c {: RESULT = c; :} |
                type_cast:e {: RESULT = e; :}
;     

type_cast ::= LPAR TYPE:t RPAR simple_expr:e {:
					RESULT = new TypeCast(tleft, tright, e, t); :};

expr_list ::= expr:e {: 
				RESULT = new Vector<Expression>(); 
				RESULT.add(e); :} |
			  expr_list:elist COLON expr:e {:
			    elist.add(e);
			    RESULT = elist; :}
;

constant ::= INT:e {: RESULT = new ConstantExpr(eleft, eright, e); :} | 
			 REAL:e  {: RESULT = new ConstantExpr(eleft, eright, e); :} |
			 STRING:e {: RESULT = new ConstantExpr(eleft, eright, e); :} |
			 BOOLEAN:e {: RESULT = new ConstantExpr(eleft, eright, e); :};                        
